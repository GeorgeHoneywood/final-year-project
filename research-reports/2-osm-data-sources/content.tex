In order to produce a map using OpenStreetMap data, you first need to decide which source/format of data to use. Traditionally, for this project, students use the OpenStreetMap editing API\@. This however, has a number of limitations, some of which I have already discussed in the project plan.

\begin{itemize}
    \item It is designed for map editing applications, and the terms of service explicitly prohibit read-only uses~\cite{osm-owg-tile-usage-policy}.
    \item You can only download a relatively limited geographical area, usually only around 2 km\(^2\). This has the effect that you will not be able to zoom out to see a large area, such an entire country~\cite{osm-wiki-limited-area}.
    \item Complex structures (like buildings with internal courtyards) represented in OpenStreetMap as multipolyons require extensive parsing and validation to correctly display.
\end{itemize}

For online maps, it is common to use either raster or vector ``map tiles''. Raster map tiles are usually 256\(\times{}\)256 \texttt{.png} files, rendered by a Mapnik server. These tiles are named according to their zoom level, and an \(x\) and \(y\) value, where \(x\) and \(y\) are offsets from the top left most tile~\cite{osm-wiki-tile-names}. Raster tiles, however, are not particularly appropriate for offline usage, as you have to request an extremely large amount of tiles, especially when you approach high zoom levels. For example if you downloaded 4 tiles at zoom 10, you would need to download 16 at zoom 11, 64 at zoom 12, and 262144 at zoom 18. This behaviour is unacceptable as rendering tiles is computationally expensive for the OpenStreetMap Foundation, and the size of these tiles adds up.

Vector tiles use a similar scheme, with tiles also being served at Z/X/Y addresses. The key differentiator is that instead of rendered images, vector data is served to clients, and it is up to the clients to render this data into a map. This gives the clients flexibility in how they can choose to display the data, such as the colours, labels, and line thicknesses. This is usually done through stylesheets. As vector data does not pixelate like raster images, you can ``overzoom'' on vector tiles, meaning you do not have to serve tiles to such high zoom levels. One of the most popular formats for vector map tiles are Mapbox Vector tiles. These use the Google Protobuf format to store the vector data.

Vector tiles make a more appropriate offline format than raster tiles, due to their ability to ``overzoom'', and that vector data can be stored more efficiently. Unfortunately it is still not particularly suited to offline usage, as with raster tiles, you need to download many tiles to cover a large region.

Therefore, it makes sense to use a dedicated storage format, that is designed to provide map data for offline applications. The OpenStreetMap Wiki provides a number of possible options for this purpose~\cite{osm-wiki-offline}. The most popular choices are mapsforge~\cite{mapsforge}, which is used by many applications~\cite{apps-using-mapsforge}, and MBTiles (by Mapbox)~\cite{mapbox-mbtiles}. Unfortunately, as the MBTiles format is based on an SQLite database, it can't easily be used in a HTML5 app.

Mapsforge, on the other hand, uses a custom binary data format~\cite{mapsforge-binary-format}. Mapsforge only provide libraries for the Java language and the Android platform. There is partial implementation available of a parser written in JavaScript, which only supports decoding the headers and other metadata. Hence, to use this format for my project, I would need to implement my own parser, which would add substantial complexity. I may also need to tackle issues with memory usage, as parsing and rendering the file will likely require random access within it --- meaning loading the whole file into an \texttt{ArrayBuffer} or some similar structure. Using the \texttt{Blob.slice()} method in JavaScript may allow me to work around this issue.

If parsing the Mapsforge binary files is too complex, I can scale back the project to using the OSM Editing API\@. This will require less parsing work, but will still have plenty of issues to overcome in terms of rendering.
