\documentclass[a4paper,12pt]{article} %set page size, font size, and type

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{graphicx} %add pictures to document
\usepackage{fancyhdr} %change headers and footers
\usepackage{verbatim} 
\usepackage[shortlabels]{enumitem} %change list formatting
\usepackage{array}
\usepackage{tabularx} %allows "X" in tables
\usepackage{tabu} %for longtabu
\usepackage{longtable}
\usepackage{textcomp}
\usepackage{wasysym} %more symbols
\usepackage{listings} %syntax highlighting
\usepackage{fancyvrb}
\usepackage[dvipsnames]{xcolor}
\usepackage{booktabs}
\usepackage{lastpage}
\usepackage{tocloft} %table of contents modification to make lines closer
\usepackage[compact, nobottomtitles]{titlesec} %modify styles of titles
\usepackage[justification=centering,
            font={small},
            textfont={it},
            labelfont=bf]{caption} %make figure hyperlinks go to top of image
\usepackage[margin=3cm, driver=pdftex]{geometry} %make the margins smaller
\usepackage[backend=biber,
            sorting=none]{biblatex} %create bibliography
\usepackage[pdftex,
            colorlinks,
            linkcolor={red!50!black},
            citecolor={blue!50!black},
            urlcolor={blue!80!black},
            pdfauthor={George Honeywood},
            pdftitle={FYP Research Report}]{hyperref} %give the pdf hyperlinks and other jazz

\fancyhf{} %clear out headers and footers before creating own
\fancyfoot[L]{\begin{footnotesize}George Honeywood\end{footnotesize}}
\fancyfoot[R]{\begin{footnotesize}Research Report\end{footnotesize}}
\fancyfoot[C]{\begin{footnotesize}\thepage{}/\pageref*{LastPage}\end{footnotesize}}

\pagestyle{fancy} %put the footer on every page
\fancypagestyle{plain}

\setlength{\parskip}{1em} %stuff to reduce spacing and indents on paragraphs
\setlength{\parindent}{0pt}

\setcounter{secnumdepth}{2} %depth of numbering for section headings
\setcounter{tocdepth}{3} %depth of headings included in the contents

\setlist[itemize]{noitemsep, nolistsep} %make lists take up less room

\setlength{\LTpost}{0pt} %reduce space under table for longtable/longtabu
\setlength{\tabulinesep}{4pt} %spacing in tabu

% prevent long urls in the in the bibliography from overfilling (weird breaks are preferred)
\setcounter{biburlnumpenalty}{9000}
\setcounter{biburllcpenalty}{9000}
\setcounter{biburlucpenalty}{9000}

\addbibresource{sources.bib} %references for bibtex and biber

\begin{document}
{
\centering
{\scshape\large Royal Holloway, University of London\par}
\vspace{0.5cm}
{\Huge Final Year Project --- Research Report\par}
\vspace{0.2cm}
{\Large Offline HTML5 Maps Application\par}
\vspace{0.2cm}
{\Huge Offline HTML5 Technologies\par}
\vspace{0.5cm}
{\large George Honeywood --- \the\month/\the\year\par}
\vspace{0.5cm}
}

In order to create an offline HTML5 map application, I will first have to research how offline HTML5 applications work, and what technologies I'll need to become familiar with.

There are various different APIs that one can use to store data in an offline HTML5 application, such as IndexedDB, the File and Directory Entries API~\cite{w3c-file-directories-api}~\cite{mdn-file-directories-api} and localStorage. localStorage will likely not be appropriate for my use case, as it is designed for only small amounts of data. There is also the Application Cache, but this has been deprecated, and support has been removed from all major browsers~\cite{whatwg-application-cache}~\cite{mdn-application-cache}. Therefore, the Application Cache will not be suitable for a new application.

If I am to process and use a large precompiled map data format, like mbtiles~\cite{mbtiles-spec} or Mapsforge~\cite{mapsforge-spec}, using the File and Directory Entries API will likely be more appropriate. For optimal performance, it may be necessary to have a loading step, I transform from one of these formats into the IndexedDB, for usage by the app. Hopefully this step can be avoided, as it would not be ideal to have multiple copies of the data, particularly on space constrained devices.

\begin{quote}
    ``The File and Directory Entries API simulates a local file system that web apps can navigate around. You can develop apps that can read, write, and create files and directories in a sandboxed, virtual file system.''
    
    \footnotesize{--- \fullcite{mdn-file-directories-api}}
\end{quote}

Another benefit of the File and Directory Entries API~\cite{w3c-file-directories-api}, is that it has the ability to act like a local file system. This would allow my app to have a flow like:

\begin{itemize}
    \item User opens the webapp
    \item Selects map to download from list (or as an enhancement by zooming in on desired region on a low detail world map)
    \item App downloads the map file to sandboxed filesystem
    \item User goes offline
    \item Map rendered from this internally stored file
\end{itemize}

A flow like this makes sense from a user's perspective, as it follows a similar paradigm to other offline map viewers, like Organic Maps or OsmAnd (as discussed in the initial plan).

If there are issues with using the File and Directory Entries API, for example file size limits in certain browsers, it should be possible to use the plain File API instead~\cite{w3c-file-api}. The File API allows access to read single files from a user's local filesystem. Importantly for my use case of loading a large map file from a user's disk, we cannot store the entire file in RAM at once. Usefully the File API provides a \texttt{.slice()} method, which allows you to work with a smaller subsection of the file. This will likely be important to avoid out-of-memory (OOM) errors.

Using the plain file API will however come at a detriment to the user flow. Instead of being able to select and download a map within the app, the user will have to download the map file themselves, then point the app to the map file they have downloaded. This is not a major issue, but it would be preferable to have this process handled without user interaction.

Unfortunately the Files and Directory Entries API has limited support in Firefox~\cite{mdn-file-directories-api-limitations}. Critically \texttt{window.requestFileSystem()} is not supported, and this is the function that you call to gain access to a virtual filesystem. In Firefox this API can only be used through an \texttt{<input>} element, or drag and drop. This is an issue as for my application, the app would need to be able to create the virtual filesystem programmatically.

\begin{quote}
    ``Content scripts can't create file systems or initiate access to a file system.''

    \footnotesize{--- \fullcite{mdn-file-directories-api-limitations}}
\end{quote}

Hence, if I wish to use the File and Directory Entries API, which would provide a smoother user journey, I would not be able to support Firefox. For my application I think it is more important to support Firefox than have perfect UX --- so I will settle on the compromise of the user having to select the desired map file on each start, via the file picker. This will be an irritation, but unfortunately there is no widely compatible way to use a sandboxed/virtual filesystem in the browser.

One benefit of storing the map file outside the browser is that my application will not have to deal with the browser not allocating it enough storage quota for the file. For example in Chrome, you must use the Quota Management API to request persistent storage space to use~\cite{gd-offline-html5-storage}, which will prompt the user to accept the request.

Another option is to use the Cache API, which is part of Service Worker specification~\cite{w3c-service-workers-caches}, and has good cross-browser support. It has a simpler interface that should work for the application --- a pair of a request and a response object are stored, and you get a cached version of the response by providing a similar request. 

To determine which will be the best choice for the application, I will produce proof of concepts that employ the File API and the Cache API\@.

\printbibliography{}

\end{document}