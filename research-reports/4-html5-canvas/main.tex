\input{../preamble.tex}

\begin{document}
{
\centering
{\scshape\large Royal Holloway, University of London\par}
\vspace{0.5cm}
{\Huge Final Year Project --- Research Report\par}
\vspace{0.2cm}
{\Large Offline HTML5 Maps Application\par}
\vspace{0.2cm}
{\Huge The HTML5 Canvas\par}
\vspace{0.5cm}
{\large George Honeywood --- \the\month/\the\year\par}
\vspace{0.5cm}
}

The HTML5 Canvas provides another dimension to web applications, where bitmap animations or other data can be displayed interactively.

\begin{quote}
    ``HTML5 Canvas is an immediate mode bitmapped area of the screen that can be manipulated with JavaScript. Immediate mode refers to the way the canvas renders pixels on the screen. HTML5 Canvas completely redraws the bitmapped screen on every frame by using Canvas API calls from JavaScript.''

    \footnotesize{--- \fullcite{fulton2013html5}}
\end{quote}

So, in my application, the canvas is what the map will be ``drawn'' to. The canvas API provides different interfaces that you can use, known as rendering contexts~\cite{mdn-canvas-api}. For simple 2D drawing, there is the \texttt{CanvasRenderingContext2D} interface. For more intensive 2D and 3D workloads, there is the GPU accelerated \texttt{WebGLRenderingContext}, which uses an OpenGL-like system of vertex and fragment shaders~\cite{mdn-web-gl}. This is what some existing vector web map libraries use, like Mapbox's GL JS~\cite{mapbox-gl-js}.

In the long run, the \texttt{WebGLRenderingContext} would be the best choice in terms of efficiency and performance, as it is hardware accelerated. However, the \texttt{Canvas\-Rendering\-Context2D} has a far simpler API, so it makes sense to use it here.

The simplest operation I will need to use the canvas for is drawing the outlines of polygonal shapes. Note that on the canvas, \texttt{(0, 0)} is at the top left. To being drawing, you first need to get an instance of \texttt{Canvas\-Rendering\-Context2D}, which is done by calling \texttt{const ctx = canvas.getContext("2d")} on some canvas element in the DOM\@. To start on the polygon, call \texttt{ctx.beginPath()} to create a new path, that you then add data to using the \texttt{ctx.lineTo(x, y)} method. If required, you can also call \texttt{ctx.moveTo(x, y)} to have the line jump from one spot to the next. Once you have made your \texttt{.moveTo()} and \texttt{.lineTo()} calls, you then execute \texttt{ctx.stroke()} to render the line out.

Another operation I will need to perform to create a styled map is creating ``filled'' polygons. For example, \href{https://openstreetmap.org}{openstreetmap.org} renders buildings with a brown infill and a darker outline. This is achieved on the canvas in a very similar way to the polygon outline, but instead of calling \texttt{ctx.stroke()} to render the path, you call \texttt{ctx.fill()}. To control the colour, you set \texttt{ctx.fillStyle} to some desired value.

To render names of points of interest and ways to the map, I will need a method to write text to the canvas. This can be done using \texttt{ctx.fillText(`string', x, y)}~\cite{mdn-canvas-draw-text}. Unfortunately this does not make provisions for drawing text at an angle, which would be useful for drawing names of roads or boundaries, where the name follows the curve of the geometry. However, you can use the \texttt{ctx.rotate(angle)} to achieve a similar result, albeit with some more complexity~\cite{mdn-canvas-rotating}.

Another useful method for drawing a map will be the \texttt{ctx.measureText(`string')} method, which returns the pixel size that the text will be drawn at. This information can be used to prevent labels on the map overlapping, by storing each of the previously drawn labels' boundary boxes, and preventing new labels from being drawn if they are colliding.

Finally, the \texttt{Path2D} interface may be useful for my application~\cite{mdn-canvas-path-2d}. It allows you to save a path, meaning you can stroke and fill some geometry, without having to draw the path twice. Hence, it should give an efficiency boost. You use it like so:

\begin{Verbatim}
const ctx = canvas.getContext(`2d');

let path = new Path2D();
path.rect(5, 5, 20, 20);

ctx.stroke(path);
ctx.fill(path);
\end{Verbatim}

\printbibliography{}

\end{document}
