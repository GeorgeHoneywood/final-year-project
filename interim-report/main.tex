\documentclass[]{final_report}
\usepackage[backend=biber,
            sorting=none,
            language=british]{biblatex} %create bibliography
\usepackage{graphicx}
\usepackage{lastpage}
\usepackage{verbatim}
\usepackage{fancyvrb}
\usepackage[shortlabels]{enumitem} %change list formatting
\usepackage[pdftex,
            colorlinks,
            linkcolor={black},
            citecolor={black},
            urlcolor={blue!60!black},
            pdfauthor={George Honeywood},
            pdftitle={Final Year Project --- Interim Report}]{hyperref} 

% prevent long urls in the in the bibliography from overfilling (weird breaks are preferred)
\setcounter{biburlnumpenalty}{9000}
\setcounter{biburllcpenalty}{9000}
\setcounter{biburlucpenalty}{9000}

\setlist[itemize]{noitemsep, nolistsep} %make lists take up less room
\setlist[enumerate]{noitemsep}

\addbibresource{../sources.bib}

%%%%%%%%%%%%%%%%%%%%%%
%%% Input project details
\def\studentname{George Honeywood}
\def\reportyear{2022}
\def\projecttitle{Offline HTML5 Maps Application}
\def\supervisorname{Reuben Rowe}
\def\degree{BSc (Hons) in Computer Science}
\def\fullOrHalfUnit{Full Unit} % indicate if you are doing the project as a Full Unit or Half Unit
\def\finalOrInterim{Interim Report} % indicate if this document is your Final Report or Interim Report

\begin{document}

\maketitle

%%%%%%%%%%%%%%%%%%%%%%
%%% Declaration

% \chapter*{Declaration}

% This report has been prepared on the basis of my own work. Where other published and unpublished source materials have been used, these have been acknowledged.

% \vskip3em

% Word Count: 

% \vskip3em

% Student Name: \studentname

% \vskip3em

% Date of Submission: 

% \vskip3em

% Signature: GH

% \newpage

%%%%%%%%%%%%%%%%%%%%%%
%%% Table of Contents
\tableofcontents\pdfbookmark[0]{Table of Contents}{toc}

%%%%%%%%%%%%%%%%%%%%%%
%%% Your Abstract here

\begin{abstract}
    Although web maps are commonplace, offline maps are a valuable niche that are useful in certain situations, such as on mobile devices with limited data, or when roaming abroad.
    
    In this project I aim to build an offline maps application based on OpenStreetMap data. The user should be able to download map data for their area of interest, then view it by panning and zooming, like a traditional online slippy map. Time permitting, I may also add additional features that require an internet connection, like routing and Wikipedia integration. Through this project I hope to learn about how map data is projected into a rendered map. It will also teach me how to successfully develop a medium-sized application.
\end{abstract}
\newpage

% for final report:
%%%%%%%%%%%%%%%%%%%%%%
%%% Project Spec

% \chapter*{Project specification}
% \addcontentsline{toc}{chapter}{Project specification}
% Your project specification goes here.

%%%%%%%%%%%%%%%%%%%%%%
%%% Introduction
\chapter{Introduction}

\input{../plan/introduction.tex}

%% these sections have basically been covered in the introduction.
%% maybe it would be good to split the introduction out.
% \section{Issues}
% \section{Motivation}

\section{Related literature}

\section{Aims and objectives}

Here I will list some specific features that I would like to implement in the project. These are not fixed, and some may not be implemented, or others added in their place.

\begin{itemize}
    \item Download vector map data for a user-provided region (preferably at least as large as a UK county), allowing the user to browse the map offline
    \item Allow the user to pan and zoom the map. They should be able to zoom out to the view the full extent of the downloaded data.
    \item Provide a search functionality, using the Nominatim API
    \item Allow the user to route between two points, which could be implemented using OSRM, GraphHopper or Valhalla
    \item When an OSM element has been tagged with a reference to a Wikipedia article, it should show a description from Wikipedia
    \item Allow the user to save and name markers for later use
    \item When online, the application should allow the user to browse a map without having to first download any data. This could be done using raster tiles.
\end{itemize}

\section{Milestones}

% FIXME: presumably this should be in past tense

Following a timeline should help my project to proceed without any major unexpected delays, and will give me targets to aim for. At the beginning of term 1 I will focus on exploring any risky areas or technologies that I am unsure about. This will help any large questions early on in the process.

\begin{enumerate}
    \item Report on offline HTML5 technologies. Will use this to decide whether it is possible to download \& store a large amount of vector map data (>100 MB) for later rendering.\label{item:deliverable:offline-html}
    \item Proof of concept basic offline HTML5 app. Can also use this to discover any limit of how files can be stored for offline use.\label{item:deliverable:basic-offline-app}
    \item Report on the different technologies that the program could use to get OpenStreetMap data. One possibility is the Mapsforge format, or it could use the OSM editing API\@. This should help mitigate risk of using a technology that is not suitable for the project.\label{item:deliverable:osm-data}
    \item Report about how map projection works. Specifically the mathematics behind projecting the Web Mercator data that is produced by OpenStreetMap. This will ensure that I understand this key concept.\label{item:deliverable:map-projection}
    \item Proof of concept that takes some way made up of latitude longitude pairs and draws a line onto a canvas. If this is too challenging, I could use a library like D3.js.\label{item:deliverable:draw-line}
    \item Make proof of concept~\ref{item:deliverable:draw-line} interactive; allow the user to pan and zoom the map. This should be done with the scroll wheel on desktop and pinch zooming on mobile.\label{item:deliverable:pan-zoom}
    \item Proof of concept that loads some actual OSM data using the technology that I decided upon in deliverable~\ref{item:deliverable:osm-data}. If the implementation proves to be too difficult, I can pivot to another technology that I had explored in deliverable~\ref{item:deliverable:osm-data}.\label{item:deliverable:load-osm-data}
    \item Thoroughly test the application on mobile, as this will likely be the main use case for an offline map.\label{item:deliverable:mobile-testing}
    \item Add online search functionality, using the Nominatim API.\label{item:deliverable:search}
    \item Add online routing functionality, using OSRM, GraphHopper or Valhalla.\label{item:deliverable:routing}
    \item Show point of interest information from Wikipedia, when an OSM element has been tagged to allow this.\label{item:deliverable:wikipedia}
    \item Add the ability to save and name markers for later use.\label{item:deliverable:markers}
    \item Allow the user to browse the map without first downloading data when online. This could be done using raster tiles.\label{item:deliverable:online}
\end{enumerate}

\subsection{Term 1}

\begin{itemize}
    \item \textbf{Week 3 (2022/10/03)}: Report~\ref{item:deliverable:offline-html}.
    \item \textbf{Week 4 (2022/10/10)}: Proof of concept~\ref{item:deliverable:basic-offline-app} \& report~\ref{item:deliverable:osm-data}.
    \item \textbf{Week 5 (2022/10/17)}: Report~\ref{item:deliverable:map-projection} \& proof of concept~\ref{item:deliverable:draw-line}.
    \item \textbf{Week 6--7 (2022/10/24)}: Proof of concept~\ref{item:deliverable:pan-zoom}.
    \item \textbf{Week 8--9 (2022/11/07)}: Proof of concept~\ref{item:deliverable:load-osm-data}.
    \item \textbf{Week 10--11 (2022/11/21)}: Prepare for the interim report, and presentation.
\end{itemize}

\subsection{Term 2}

\begin{itemize}
    \item \textbf{Week 1--2 (2023/01/10)}: Integration of the above proof of concepts into the final program.
    \item \textbf{Week 3--4 (2023/01/24)}: Deliverable~\ref{item:deliverable:mobile-testing}.
    \item \textbf{Week 5 (2023/02/07)}: Prepare an initial draft for the final report.
    \item \textbf{Week 6--7 (2023/02/14)}: Add support for further features, such as deliverables \ref{item:deliverable:search}, \ref{item:deliverable:routing}, \ref{item:deliverable:wikipedia}, \ref{item:deliverable:markers} and \ref{item:deliverable:online}.
    \item \textbf{Week 8 (2023/02/28)}: Evaluate the solution so far, and decide whether to extend the project further, if time permits.
    \item \textbf{Week 9--11 (2023/03/27)}: Prepare for the final report.
\end{itemize}

\chapter{Research}

\section{Basic HTML5 technologies}

% write another report here, only on basic stuff.

\section{Offline HTML5 applications}\label{sec:offline-html-applications}

\input{../research-reports/1-offline-html5/content.tex}

\section{Using the HTML5 canvas}

\input{../research-reports/4-html5-canvas/content.tex}

\section{OpenStreetMap data sources}

\input{../research-reports/2-osm-data-sources/content.tex}

\section{Projecting map data}\label{sec:projecting-map-data}

\input{../research-reports/3-map-projections/content.tex}

\chapter{Software engineering}

\section{Testing}

\section{Version control}

\section{Documentation}

\chapter{Proof-of-concept development process}

% talk about proof of concepts here!
% little write up of how each works, and what it achieves

As part of the development process, I have created a number of proof-of-concepts, that each build on each other. These have helped me to understand, test and evaluate various technologies that I could use to build the final application.

\section{Simple offline HTML5 app}

\hfill \texttt{proof-of-concepts/1-offline-html5}

My first proof of concept was a basic offline HTML5 application, employing the techniques that I researched in Section~\ref{sec:offline-html-applications}. Since the \texttt{Application Cache} has been deprecated, the accepted way to create an offline HTML5 app is to use Service Workers~\cite{w3c-service-workers-caches}. The concept behind this is that the Service Worker intercepts all HTTP requests that are made on the website, and can then respond to this request with a result from a prepopulated cache.

In addition to creating an offline HTML5 app, I also learned how to store a large binary blob. This will be necessary for my project, as this is how the map data will be stored. To this end I looked at using both the Service Worker cache, and the File API\@.

The File API works like a traditional file picker --- allowing the user to choose some file from their local filesystem~\cite{w3c-file-api}. This is useful, but does not provide an excellent user experience. For example the user would have to download a map file to some location on their computer, then select it in the file picker every time they want to view a map. This violates Nielsen's ``Recognition, not recall'' heuristic~\cite{nielsen-heuristics}, as the application should work without the user having to remember where they saved the map file.

Therefore, it is preferred to use the Service Worker cache method, where you store the file inside the web browser's cache. Storing binary blobs works like using the Service Worker cache for normal website resources:

\begin{lstlisting}[caption=Using the Service Worker cache]
self.addEventListener('install', (event) =>  event.waitUntil(
        addResourcesToCache(['/index.html', '/blob.map']) // prepopulate cache
));

const cacheFirst = async ({ request }) => {
    const responseFromCache = await caches.match(request);
    if (responseFromCache) { // try to get the resource from the cache
        return responseFromCache;
    }

    return new Response('could not retrieve from cache', {
            status: 408,
            headers: { 'Content-Type': 'text/plain' },
        });
};

self.addEventListener('fetch', (event) => event.respondWith(
        cacheFirst({request: event.request})
));
\end{lstlisting}

\section{Rendering geometry to a canvas}

\hfill \texttt{proof-of-concepts/2-rendering-a-way}

My second proof of concept was to draw some geographical data on to the canvas. As a first step, I had to acquire some data to project. As this was a simple proof of concept I decided to use the GeoJSON format, which a popular standard for representing geodata, in a fairly human-readable format. The main reason I chose it was that it is easier to parse in JavaScript than the XML data that the OpenStreetMap API provides~\cite{osm-api-wiki}. For my first test, I attempted to render the boundary of Egham, which is currently \href{https://www.openstreetmap.org/way/666914693}{way 666914693}. To convert XML data from OpenStreetMap I used the online \texttt{geojson.io} tool, which allows you to import OSM XML and export GeoJSON~\cite{geojson.io}.

The main challenge I wanted to solve in this proof of concept was projecting the data. This stage is necessary, as OpenStreetMap data comes in the WGS84 CRS, and while this can be naively plotted on a graph as (x,y) coordinates, this would result in the ``plate carrée'' projection, as detailed in Section~\ref{sec:projecting-map-data}. The ``plate carrée'' projection is not particularly desirable, as it does not have any useful properties like conformality (preservation of angle) or preservation of area. Hence, for my application I chose to use Web Mercator, which preserves conformality, and is the de facto standard for web maps.

Initially, I attempted to use the algorithm from \textcite[41]{snyder1987map}, as shown in Section~\ref{sec:projecting-map-data}. Unfortunately I had some issues with getting these equations to produce reasonable results. Therefore, I turned to the OpenStreetMap Wiki, which helpfully provides a reference for transforming WGS84 data into the Web Mercator projection~\cite{osm-wiki-mercator}. I translated the C example into TypeScript, and it correctly projected the data.

\begin{lstlisting}[caption=Projecting to Web Mercator]
const RADIANS_TO_DEGREES = 180 / Math.PI;

// calculate x/long
const x = long;
// calculate y/lat
const y = Math.log(Math.tan(
    (lat / RADIANS_TO_DEGREES) / 2 + Math.PI / 4
)) * RADIANS_TO_DEGREES;
\end{lstlisting}

\begin{figure}[ht]
    \centering
    \includegraphics[width=0.7\textwidth]{../proof-of-concepts/2-rendering-a-way/screenshots/ferndown-buildings.png}
    \caption{Rendering some GeoJSON data to the canvas}
\end{figure}\label{fig:rendering-geometry}

This proof of concept was entirely static, with the viewport and zoom level hardcoded into the program. To make the implementation simpler I wrote a function that scaled all the coordinates to be around (0,0), so that I didn't have to handle offsetting the viewport.

\section{Adding interactivity --- panning and zooming}

\hfill \texttt{proof-of-concepts/3-panning-and-zooming}

The third proof of concept heavily built upon this second --- with the goal of adding interactivity in the form of panning and zooming. As being mobile friendly is a priority for my project, I made sure to add touch controls once I had it working with mouse events.

The first part I tackled was the zooming. This turned out to be as simple as multiplying each projected coordinate by some scale factor, which I was already doing in the previous proof of concept. To modify this scale factor, the user can use the +/- buttons, the mouse scroll wheel, or a pinch gesture on a touch device. Pinch gestures were the most challenging to implement, as you have to handle and interpret \texttt{Touch} events for each separate finger on the screen.

Panning also turned out to be relatively easy --- my implementation involved adding some offsets to the projected and scaled coordinates in the latitude and longitude axis. What was more complicated was having the map zoom about some arbitrary point. For example, on desktop, you expect a map to zoom into the position of your mouse cursor, on into the middle of your pinch gesture on mobile. To achieve this, I update the \texttt{x} and \texttt{y} offsets whenever you zoom, with a smaller offset change when zooming into the top left, and a larger one for the bottom right. Another issue I had to handle is that at a low zoom level, zooming was relatively quick, but once you reached higher zoom levels, it got slower and slower. To compensate for this I made the scale factor logarithmic.

\begin{figure}[ht]
    \centering
    \includegraphics[width=\textwidth]{../proof-of-concepts/3-panning-and-zooming/screenshots/the-world.png}
    \caption{An interactive world map, using Natural Earth data~\cite{natural-earth}}
\end{figure}\label{fig:panning-and-zooming}

For testing the zooming between low and high zoom, I needed some ``large scale'' data to supplement the localized OSM data that I had downloaded for the previous proof of concept. Natural Earth Cultural Vector data seemed suitable, as it is readily available as GeoJSON, is released in the public domain, and is suitably low-detail for my purpose~\cite{natural-earth}. Once again I used \texttt{geojson.io}~\cite{geojson.io}, this time to merge these two sets of data.

To begin with, I was simply redrawing the map every time a \texttt{Touch} or \texttt{Mouse} event fired. This worked, but these events would often fire very rapidly (>60 times/second), resulting in a slow panning experience, where rendering was occurring unnecessarily. My solution for this was \texttt{requestAnimationFrame()}, which allows you to have some function executed at a regular interval by the browser~\cite{mdn-request-animation-frame}. Therefore, I could to modify the state of the map, then have it smoothly rendered at regular intervals to reflect any changes to zoom or offsets. 

Unfortunately this change meant the canvas re-rendered 60 times a second at all times, even when no state change had occurred, which is a waste of processing power and energy, especially on mobile devices. To remedy this I introduced a \texttt{dirty} flag, which I set whenever a state change had occurred, checking it at the beginning of the \texttt{render()} function. The end result was a map that updated smoothly 60 times a second when state changes were occurring, and not at all when the map was static.

\section{Rendering tiled data from a Mapsforge file}

\hfill \texttt{proof-of-concepts/4-rendering-osm-data}

My final proof of concept revolved around reading tiled OSM data from a Mapforge formatted binary file~\cite{mapsforge-format}. This allows for a map viewer that is performant at a wide range of zoom levels, as it can switch to more detailed data as you zoom in, and less detailed as you zoom out. It also solves the issue of which data to render --- my previous proof of concepts rendered all the data, all the time, even if it was off canvas. With tiled data, you only have to render the tiles that are current within the viewport.

%% for final report:
%\chapter{Final application development process}

\chapter{Conclusion}

%% for final report:
% \section{Professional issues}
% look on the BCS website for ideas

\section{Evaluation}

\addcontentsline{toc}{chapter}{Bibliography}

% smaller bibliography text
\renewcommand*{\bibfont}{\normalfont\small}
\printbibliography{}

\end{document}
